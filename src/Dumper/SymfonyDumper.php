<?php

namespace Creads\Api2Symfony\Dumper;

use Creads\Api2Symfony\Mock\ControllerMock;
use Creads\Api2Symfony\Mock\ActionMock;
use Creads\Api2Symfony\Mock\ResponseMock;


use DocDigital\Lib\SourceEditor\TokenParser;
use DocDigital\Lib\SourceEditor\PhpClassEditor;
use DocDigital\Lib\SourceEditor\ElementBuilder;
use DocDigital\Lib\SourceEditor\ClassStructure\ClassElement;
use DocDigital\Lib\SourceEditor\ClassStructure\DocBlock;
use DocDigital\Lib\SourceEditor\ClassStructure\MethodElement;

// use Creads\Api2Symfony\Definition\DefinitionDumper;
// use Creads\Api2Symfony\Definition\Definition;
// use Creads\Api2Symfony\Definition\Method;
// use Creads\Api2Symfony\Definition\Property;

/**
 * Dump a symfony controller
 *
 * @author Damien Pitard <d.pitard@creads.org>
 */
class SymfonyDumper extends AbstractFileDumper
{
    const INDENT_SPACES = 4;

    protected $test;

    /**
     * {@inheritDoc}
     */
    protected function render(ControllerMock $controller)
    {
        $class = $this->getClass($controller);

        $this->test = $class;

        return $class->render(false);
    }

    public function dump(ControllerMock $controller, $destination = '.')
    {
        $filepath = parent::dump($controller, $destination);

        $editor = new PhpClassEditor(new TokenParser());
        $editor->parseFile($filepath);

        $name = basename(str_replace('\\', '/', $this->test->getName()));

        $class = $editor->getClass($name);

var_dump($class);
var_dump($this->test);


        die();

        return $filepath;
    }

    /**
     * Get class definition corresponding to ControllerMock
     *
     * @param ControllerMock $controller
     *
     * @return ClassElement
     */
    protected function getClass(ControllerMock $controller)
    {
        $class = new ClassElement();

        $class->setName($controller->getClassName());
        $class->setClassDef('class ' . $controller->getShortClassName() . ' extends Controller');
        $class->setNameSpace('namespace ' . $controller->getNamespace() . ';');
        $class->addUse('use Symfony\Bundle\FrameworkBundle\Controller\Controller;');
        $class->addUse('use Symfony\Component\HttpFoundation\Request;');
        $class->addUse('use Symfony\Component\HttpFoundation\Response;');
        $class->addUse('use Symfony\Component\HttpKernel\Exception\HttpException;');
        $class->addUse('use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;');
        $class->addUse('use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;');
        $class->addUse('use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;');

        $description = $controller->getDescription()?$controller->getDescription():'<no description>';
        $class->addDocBlock(new DocBlock(
<<< EOT
/**
* {$description}
*
* This class has been auto-generated by Api2Symfony.
* @see https://github.com/creads/api2symfony
*/
EOT
        ));

        foreach ($controller->getActions() as $action) {
            $method = $this->getMethod($action, $class);
            $class->addMethod($method);
        };

        return $class;
    }

    /**
     * Get method definition corresponding to action mock
     *
     * @param ActionMock $action
     *
     * @return MethodElement
     */
    protected function getMethod(ActionMock $action, ClassElement $class)
    {
        $method = new MethodElement($class);
        $method->setName($action->getName());
        $description = $action->getDescription()?$action->getDescription():'<no description>';
        $method->setSignature(new ElementBuilder('public function ' . $action->getName() . '(Request $request)'));
        $method->addDocBlock(new DocBlock(
<<< EOT
/**
 * {$description}
 *
 * @Route(
 *   "{$action->getRoute()->getPath()}",
 *   name="{$action->getRoute()->getName()}"
 * )
 * @Method({"{$action->getMethod()}"})
 *
 * @return Response
 */
EOT
            )
        );

        foreach ($action->getResponses() as $response) {
            $e = $this->getResponse($response);
            $method->addBodyElement($e);

        }

        $method->addBodyElement(new ElementBuilder(
<<< EOT

        //returns an exception if the api does not know how to handle the request
        throw new BadRequestHttpException("Don't know how to handle this request");
EOT
        ));

        return $method;
    }

    /**
     * Get code corresponding to ResponseMock
     *
     * @param ResponseMock $response
     *
     * @return ElementBuilder
     */
    protected function getResponse(ResponseMock $response)
    {
        $body = trim(addcslashes($response->getBody(), "'"));
        $description = $response->getDescription()?$response->getDescription():'<no description>';
        $headers = var_export($response->getHeaders(), true);
        if ($response->getCode() >= 200 && $response->getCode() < 300) { //valid response
            $headers = self::renderArray($response->getHeaders(), 4);
            $body = "'" . $body . "',";
            $e = new ElementBuilder(
<<< EOT

        if ('{$response->getFormat()}' === \$request->get('_format')) {

            return new Response(
{$body}
                {$response->getCode()},
                {$headers}
            );
        }

EOT
            );
        } else { //invalid response
            $headers = self::renderArray($response->getHeaders(), 3);
            $body = self::renderComment("'" . $body . "'") . ",";
            $e = new ElementBuilder(
<<< EOT

//         throw new HttpException(
//             {$response->getCode()},
{$body}
//             null,
//             {$headers}
//         );

EOT
            );
        }

        return $e;
    }


    /**
     * Export an array.
     *
     * Based on Symfony\Component\DependencyInjection\Dumper\PhpDumper::exportParameters
     * http://github.com/symfony/symfony
     *
     * @param array $array  The array.
     *
     * @return string The array exported.
     */
    public static function renderArray(array $array, $tabs = 0)
    {
        // return var_export($array, true);

        if (count($array)) {

            $code = array();
            foreach ($array as $key => $value) {
                if (is_array($value)) {
                    $value = self::exportArray($value, $tabs + 1);
                } else {
                    $value = null === $value ? 'null' : var_export($value, true);
                }

                $code[] = sprintf('%s%s => %s,', str_repeat(' ', ($tabs+1) * self::INDENT_SPACES), var_export($key, true), $value);
            }

            return sprintf("array(\n%s\n%s)", implode("\n", $code), str_repeat(' ', $tabs * self::INDENT_SPACES));
        } else {
            return 'array()';
        }
    }

    /**
     * Indents code with tabs (4 spaces)
     *
     * @return string
     */
    public static function renderIndent($code, $tabs = 0)
    {
        $output = '';
        $lines = preg_split('/\r\n|\r|\n/', $code);
        $count = count($lines);
        foreach ($lines as $i => $line) {
            $line = rtrim($line);
            if (!empty($line)) {
                str_repeat(' ', $tabs * self::INDENT_SPACES);
                $output .= $line;
            }
            if ($i < ($count - 1)) {
                $output .= "\n";
            }
        }

        return $output;
    }

    /**
     * Comments code with simple line comment (//)
     *
     * @return string
     */
    public static function renderComment($code)
    {
        $output = '';
        $lines = preg_split('/\r\n|\r|\n/', $code);
        $count = count($lines);
        foreach ($lines as $i => $line) {
            $line = rtrim($line);
            if (!empty($line)) {
                $output .= '// ' . $line;
            }
            if ($i < ($count - 1)) {
                $output .= "\n";
            }
        }

        return $output;
    }

    /**
     * Comments code in a docblock
     *
     * @return string
     */
    public static function renderDocblockComment($code)
    {
        $output = "/**\n";
        $lines = preg_split('/\r\n|\r|\n/', $code);
        foreach ($lines as $i => $line) {
            $output .= ' * ' . $line . "\n";
        }
        $output .= " */";
        return $output;
    }

    /**
     * Comments code with multiline comment
     *
     * @return string
     */
    public static function renderMultiComment($code)
    {
        $output = "/*\n";
        $lines = preg_split('/\r\n|\r|\n/', $code);
        foreach ($lines as $i => $line) {
            $output .= $line . "\n";
        }
        $output .= "*/";

        return $output;
    }
}
